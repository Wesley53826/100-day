<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Gesture Christmas Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* æ‘„åƒå¤´ç”»ä¸­ç”» (è°ƒè¯•ç”¨ï¼Œå¯éšè—) */
        .input_video {
            position: absolute; top: 10px; right: 10px; width: 160px; height: 120px;
            z-index: 2; border-radius: 8px; opacity: 0.7; transform: scaleX(-1); display: none;
        }

        /* åŠ è½½ä¸å¯åŠ¨ç•Œé¢ */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #fff; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 10;
        }
        #start-btn {
            padding: 15px 30px; font-size: 18px; background: #d42426; color: white;
            border: none; border-radius: 25px; cursor: pointer; margin-top: 20px;
        }
        #status { margin-top: 10px; color: #888; font-size: 12px; }
        
        /* äº¤äº’æç¤º */
        #guide {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.6); pointer-events: none; z-index: 3;
            font-size: 14px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <video class="input_video" playsinline webkit-playsinline muted></video>

    <audio id="bgm" loop>
        <source src="./music.mp3" type="audio/mpeg">
    </audio>

    <div id="loading">
        <h1>ğŸ„ 3D åœ£è¯æ ‘ç›¸å†Œ</h1>
        <p>éœ€è¦æ‘„åƒå¤´æƒé™ä»¥è¯†åˆ«æ‰‹åŠ¿</p>
        <div id="status">æ­£åœ¨åˆå§‹åŒ–ç»„ä»¶...</div>
        <button id="start-btn" disabled>ç‚¹å‡»å¼€å§‹</button>
    </div>

    <div id="canvas-container"></div>
    
    <div id="guide">å¼ å¼€æ‰‹æŒï¼šç‚¸è£‚ | æ¡ç´§æ‹³å¤´ï¼šèšåˆ | ç‚¹å‡»ç…§ç‰‡ï¼šæ”¾å¤§æŸ¥çœ‹</div>

<script>
    // ================= é…ç½®åŒºåŸŸ =================
    const imageUrls = [];
    // æ ¹æ®ä½ æˆªå›¾ä¸­çš„æ–‡ä»¶æ•°é‡ï¼Œå‡è®¾ä½ æœ‰ 20 å¼ å·¦å³ï¼Œå¦‚æœæœ‰æ›´å¤šï¼Œä¿®æ”¹ä¸‹é¢è¿™ä¸ªæ•°å­—
    const photoCount = 90; 

    // è‡ªåŠ¨ç”Ÿæˆç¬¦åˆä½ æ–‡ä»¶åçš„è·¯å¾„ï¼šimage (1).jpeg, image (2).jpeg ...
    for (let i = 1; i <= photoCount; i++) {
        // æ³¨æ„ï¼šè¿™é‡Œä¸¥æ ¼åŒ¹é…äº†ä½ çš„æ–‡ä»¶åæ ¼å¼ï¼ˆåŒ…å«ç©ºæ ¼å’Œæ‹¬å·ï¼‰
        imageUrls.push(`./image (${i}).jpeg`);
    }

    // ================= æ€§èƒ½ä¼˜åŒ–å·¥å…·ï¼šå›¾ç‰‡å‹ç¼© =================
    // åŠŸèƒ½ï¼šå°†å¤§å›¾ç»˜åˆ¶åˆ°å° Canvas ä¸Šï¼Œè¿”å› Base64ï¼Œå‡å°‘æ˜¾å­˜å ç”¨
    function compressImage(url, width = 128) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = "Anonymous"; // å¤„ç†è·¨åŸŸ
            img.src = url;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const scale = width / img.width;
                canvas.width = width;
                canvas.height = img.height * scale;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                resolve({
                    src: canvas.toDataURL('image/jpeg', 0.8), // è¿”å›å‹ç¼©åçš„ base64
                    originalSrc: url, // ä¿å­˜åŸå›¾é“¾æ¥ç”¨äºæ”¾å¤§
                    aspect: img.width / img.height
                });
            };
            img.onerror = (e) => {
                console.warn("Image load failed", url);
                resolve(null); // å¿½ç•¥é”™è¯¯å›¾ç‰‡
            };
        });
    }

    // ================= Three.js æ ¸å¿ƒé€»è¾‘ =================
    let scene, camera, renderer;
    let particles = [];
    let state = 'tree'; // tree, explode, viewing
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let currentViewObject = null; // å½“å‰æ”¾å¤§æŸ¥çœ‹çš„å¯¹è±¡

    // åˆå§‹åŒ– 3D åœºæ™¯
    async function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        // æ˜Ÿç©ºèƒŒæ™¯é›¾æ•ˆ
        scene.fog = new THREE.FogExp2(0x000000, 0.0008);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 100, 400);
        camera.lookAt(0, 50, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”ä»¥ä¼˜åŒ–æ€§èƒ½
        container.appendChild(renderer.domElement);

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(0, 200, 100);
        scene.add(dirLight);

        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        await createParticles();

        // äº¤äº’äº‹ä»¶
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('click', onMouseClick, false);
        window.addEventListener('touchstart', onTouchStart, false);
        
        animate();
    }

    // åˆ›å»ºç…§ç‰‡ç²’å­
    async function createParticles() {
        const statusDiv = document.getElementById('status');
        statusDiv.innerText = "æ­£åœ¨å‹ç¼©å¹¶ç”Ÿæˆç…§ç‰‡çº¹ç†...";
        
        let loadedCount = 0;
        // å¦‚æœå›¾ç‰‡å°‘ï¼Œå¾ªç¯ä½¿ç”¨è¿™äº›å›¾ç‰‡å¡«æ»¡æ ‘
        const targetParticleCount = 80; 
        
        // èºæ—‹å½¢åœ£è¯æ ‘å‚æ•°
        const radiusStep = 4; // åŠå¾„å¢é•¿æ­¥é•¿
        const heightStep = 3; // é«˜åº¦æ­¥é•¿
        const angleStep = 0.4; // è§’åº¦æ­¥é•¿

        for (let i = 0; i < targetParticleCount; i++) {
            // å¾ªç¯å–å›¾ç‰‡
            const urlIndex = i % imageUrls.length;
            const imgUrl = imageUrls[urlIndex];

            // 1. ç”Ÿæˆå‹ç¼©çº¹ç†
            const imgData = await compressImage(imgUrl);
            if (!imgData) continue;

            loadedCount++;
            if(loadedCount % 5 === 0) {
                 statusDiv.innerText = `åŠ è½½èµ„æº: ${loadedCount} / ${targetParticleCount}`;
            }

            // 2. åˆ›å»ºæè´¨
            const texture = new THREE.TextureLoader().load(imgData.src);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true
            });

            // 3. åˆ›å»º Mesh (å¹³é¢)
            const geometry = new THREE.PlaneGeometry(15, 15 / imgData.aspect);
            const mesh = new THREE.Mesh(geometry, material);

            // 4. è®¡ç®—â€œæ ‘â€å½¢æ€çš„åæ ‡
            const angle = i * angleStep;
            const y = 200 - (i * heightStep); // ä»ä¸Šå¾€ä¸‹
            const r = (200 - y) / 3 + 10; // åŠå¾„éšé«˜åº¦å˜å¤§
            const x = r * Math.cos(angle);
            const z = r * Math.sin(angle);

            // 5. è®¡ç®—â€œçˆ†ç‚¸â€å½¢æ€çš„åæ ‡ (éšæœº)
            const explodeX = (Math.random() - 0.5) * 800;
            const explodeY = (Math.random() - 0.5) * 800;
            const explodeZ = (Math.random() - 0.5) * 800;

            // å­˜å‚¨æ•°æ®
            mesh.userData = {
                treePos: { x, y, z },
                treeRot: { x: 0, y: -angle, z: 0 },
                explodePos: { x: explodeX, y: explodeY, z: explodeZ },
                explodeRot: { x: Math.random() * Math.PI, y: Math.random() * Math.PI, z: Math.random() * Math.PI },
                originalUrl: imgData.originalSrc, // ä¿å­˜é«˜æ¸…å›¾é“¾æ¥
                isViewing: false
            };

            // åˆå§‹ä½ç½®è®¾ä¸ºæ ‘
            mesh.position.set(x, y, z);
            mesh.rotation.set(0, -angle, 0);

            scene.add(mesh);
            particles.push(mesh);
        }

        // æ ‘é¡¶æ˜Ÿæ˜Ÿ
        const starGeo = new THREE.OctahedronGeometry(10, 0);
        const starMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffaa00 });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.set(0, 215, 0);
        
        // æ˜Ÿæ˜ŸåŠ¨ç”»æ•°æ®
        star.userData = { isStar: true };
        scene.add(star);
        particles.push(star); // è®©æ˜Ÿæ˜Ÿä¹Ÿå‚ä¸çˆ†ç‚¸

        statusDiv.innerText = "å‡†å¤‡å°±ç»ªï¼";
        document.getElementById('start-btn').disabled = false;
        document.getElementById('start-btn').innerText = "å¯åŠ¨ä½“éªŒ";
    }

    // ================= åŠ¨ç”»æ§åˆ¶ =================

    function transformTo(shape) {
        if (state === 'viewing') return; // æŸ¥çœ‹å›¾ç‰‡æ—¶é”å®š
        
        state = shape; // 'tree' or 'explode'

        particles.forEach(obj => {
            if (obj.userData.isViewing) return; // ä¸å½±å“å½“å‰æŸ¥çœ‹çš„å›¾ç‰‡

            const targetPos = shape === 'tree' 
                ? (obj.userData.treePos || {x:0, y:215, z:0}) 
                : (obj.userData.explodePos || {x:0, y:1000, z:0});
            
            const targetRot = shape === 'tree'
                ? (obj.userData.treeRot || {x:0, y:0, z:0})
                : (obj.userData.explodeRot || {x:0, y:0, z:0});

            // ä½ç½®åŠ¨ç”»
            new TWEEN.Tween(obj.position)
                .to(targetPos, 2000)
                .easing(TWEEN.Easing.Exponential.InOut)
                .start();

            // æ—‹è½¬åŠ¨ç”»
            new TWEEN.Tween(obj.rotation)
                .to(targetRot, 2000)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();
        });
    }

    // ç‚¹å‡»/è§¦æ‘¸å¤„ç† (æŸ¥çœ‹è¯¦æƒ…)
    function handleInteraction(x, y) {
        // å¦‚æœæ­£åœ¨æŸ¥çœ‹ï¼Œç‚¹å‡»ä»»æ„å¤„æ¢å¤
        if (state === 'viewing' && currentViewObject) {
            resetView(currentViewObject);
            return;
        }

        // å½’ä¸€åŒ–åæ ‡
        mouse.x = (x / window.innerWidth) * 2 - 1;
        mouse.y = -(y / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(particles);

        if (intersects.length > 0) {
            const selected = intersects[0].object;
            if (selected.userData.isStar) return; // æ˜Ÿæ˜Ÿä¸æ”¾å¤§
            
            zoomIn(selected);
        }
    }

    function zoomIn(obj) {
        state = 'viewing';
        currentViewObject = obj;
        obj.userData.isViewing = true;

        // 1. é£åˆ°æ‘„åƒæœºå‰æ–¹
        const targetPos = new THREE.Vector3(0, 0, -100); // ç›¸å¯¹ç›¸æœºçš„ä½ç½®
        targetPos.applyMatrix4(camera.matrixWorld);

        // 2. é¢å‘ç›¸æœº
        const targetRot = camera.rotation.clone();

        new TWEEN.Tween(obj.position).to(targetPos, 1000).easing(TWEEN.Easing.Quintic.Out).start();
        new TWEEN.Tween(obj.rotation).to({x: targetRot.x, y: targetRot.y, z: targetRot.z}, 1000).start();
        new TWEEN.Tween(obj.scale).to({x: 5, y: 5, z: 5}, 1000).start(); // æ”¾å¤§

        // 3. æ­¤æ—¶åŠ è½½é«˜æ¸…åŸå›¾
        if (obj.userData.originalUrl) {
            new THREE.TextureLoader().load(obj.userData.originalUrl, (hdTexture) => {
                if (obj.userData.isViewing) { // å†æ¬¡æ£€æŸ¥ä»¥é˜²ç”¨æˆ·ç‚¹å¤ªå¿«
                    obj.material.map = hdTexture;
                    obj.material.needsUpdate = true;
                }
            });
        }
    }

    function resetView(obj) {
        state = 'tree'; // æˆ–è€…æ˜¯ explodeï¼Œå–å†³äºä¸Šä¸€ä¸ªçŠ¶æ€ï¼Œè¿™é‡Œç®€å•å¤„ç†å› tree
        obj.userData.isViewing = false;
        currentViewObject = null;
        
        // æ¢å¤å¤§å°
        new TWEEN.Tween(obj.scale).to({x: 1, y: 1, z: 1}, 800).start();
        
        // æ¢å¤ä½ç½®
        const targetPos = obj.userData.treePos;
        const targetRot = obj.userData.treeRot;
        
        new TWEEN.Tween(obj.position).to(targetPos, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
        new TWEEN.Tween(obj.rotation).to(targetRot, 1000).start();
    }

    function onMouseClick(event) {
        handleInteraction(event.clientX, event.clientY);
    }

    function onTouchStart(event) {
        if (event.touches.length > 0) {
            handleInteraction(event.touches[0].clientX, event.touches[0].clientY);
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();
        
        // ç®€å•çš„è‡ªè½¬ï¼Œä»…åœ¨æ ‘å½¢æ€ä¸”æ²¡äººæŸ¥çœ‹å›¾ç‰‡æ—¶
        if (state === 'tree' && !currentViewObject) {
            scene.rotation.y += 0.001;
        }

        renderer.render(scene, camera);
    }

    // ================= MediaPipe æ‰‹åŠ¿è¯†åˆ« =================
    
    const videoElement = document.getElementsByClassName('input_video')[0];
    let isVideoRunning = false;
    let lastGesture = 'none';

    function onResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

        // è·å–ç¬¬ä¸€åªæ‰‹
        const landmarks = results.multiHandLandmarks[0];
        
        // ç®€å•çš„æ‰‹åŠ¿é€»è¾‘
        const wrist = landmarks[0];
        const tip = landmarks[12];
        const distance = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
        
        let gesture = 'none';
        if (distance > 0.35) { 
            gesture = 'open';
        } else if (distance < 0.25) {
            gesture = 'closed';
        }

        // çŠ¶æ€æœº
        if (gesture !== lastGesture) {
            if (gesture === 'open') {
                transformTo('explode');
            } else if (gesture === 'closed') {
                transformTo('tree');
            }
            lastGesture = gesture;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // ================= å¯åŠ¨æµç¨‹ =================
    document.getElementById('start-btn').addEventListener('click', async () => {
        document.getElementById('loading').style.display = 'none';
        
        // 0. æ’­æ”¾éŸ³ä¹ (å¿…é¡»åœ¨ç”¨æˆ·äº¤äº’åè°ƒç”¨)
        const bgm = document.getElementById('bgm');
        bgm.volume = 0.5; // éŸ³é‡ 50%
        bgm.play().catch(e => console.log("Music play failed:", e));

        // 1. åˆå§‹åŒ– 3D
        await initThree();

        // 2. å¯åŠ¨æ‘„åƒå¤´
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        try {
            await cameraUtils.start();
        } catch(e) {
            console.error("Camera error:", e);
            alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·ç¡®ä¿åœ¨ HTTPS ç¯å¢ƒä¸‹ã€‚æ‚¨ä»å¯ç‚¹å‡»å›¾ç‰‡äº’åŠ¨ã€‚");
        }
    });
</script>
</body>
</html>